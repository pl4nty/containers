name: release

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      targets:
        description: Target folder names as JSON array
        type: string
      targets-windows:
        description: Windows target folder names as JSON array
        type: string

# changed-files filters aren't sufficient, and runtime filtering is expensive
env:
  TARGETS_WINDOWS: |
    azure-ad-app-proxy/**
    universal-print-connector/**

jobs:
  get-targets:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    outputs:
      targets: ${{ steps.targets.outputs.targets }}
      targets-windows: ${{ steps.targets-windows.outputs.targets }}
    steps:
    - uses: actions/checkout@v3.5.3
      if: ${{ github.event_name != 'pull_request' && github.event_name != 'workflow_dispatch' }}
      with:
        fetch-depth: 2
        submodules: true
        token: ${{ secrets.GH_PAT }} # private submodules

    - uses: tj-actions/changed-files@v37.0.5
      if: ${{ github.event_name != 'workflow_dispatch' }}
      id: changed-files
      with:
        fetch_depth: 2
        dir_names: true # output folders instead of files
        dir_names_max_depth: 1 # only return roots, not subfolders
        dir_names_exclude_current_dir: true # exclude root files
        files_ignore: |
          .github/**
          archive/**
        json: true # output in matrix JSON format

    - uses: tj-actions/changed-files@v37.0.5
      if: ${{ github.event_name != 'workflow_dispatch' }}
      id: changed-files-windows
      with:
        fetch_depth: 2
        dir_names: true # output folders instead of files
        dir_names_max_depth: 1 # only return roots, not subfolders
        dir_names_exclude_current_dir: true # exclude root files
        files_ignore: |
          .github/**
          archive/**
          ${{ env.TARGETS_WINDOWS }}
        json: true # output in matrix JSON format

    - id: targets
      run: |
        echo "targets=${{ github.event_name == 'workflow_dispatch' && inputs.targets || steps.changed-files.outputs.all_changed_and_modified_files }}" >> $GITHUB_OUTPUT
        echo "targets-windows=${{ github.event_name == 'workflow_dispatch' && inputs.targets-windows || steps.changed-files-windows.outputs.all_changed_and_modified_files }}" >> $GITHUB_OUTPUT

  build-windows:
    needs: get-targets
    permissions:
      packages: write # push images
      id-token: write # OIDC artifact signing
    strategy:
      matrix:
        target: ${{ fromJson(needs.get-targets.outputs.targets-windows) }}
    runs-on: windows-latest
    steps:
    - uses: actions/checkout@v3.5.3
      with:
        submodules: recursive
        token: ${{ secrets.GH_PAT }} # private submodules

    - name: Add patches to submodule
      id: add-patches
      working-directory: ${{ matrix.target }}
      continue-on-error: true
      run: |
        cp * ${{ matrix.target }} -r
        echo "context=${{ matrix.image }}/${{ matrix.image }}" >> $GITHUB_OUTPUT

    - uses: docker/metadata-action@v4
      id: meta
      with:
        images: ghcr.io/${{ github.repository_owner }}/${{ matrix.image }}
        tags: |
          type=sha
          type=ref,event=pr
          type=raw,value=latest,enable={{is_default_branch}}

    # errors if cache doesn't exist
    # needs custom restore keys: jpribyl/action-docker-layer-caching#38
    - uses: jpribyl/action-docker-layer-caching@v0.1.1
      continue-on-error: true
      with:
        concurrency: 10
        key: docker-layer-cache-${{ matrix.image }}-windows-amd64-{hash}
        restore-keys: |
          docker-layer-cache-${{ matrix.image }}-windows-amd64-
          layer-docker-layer-cache-${{ matrix.image }}-windows-amd64-

    - uses: mr-smithers-excellent/docker-build-push@v6.2
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ github.token }}
        image: ${{ matrix.image }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        directory: ${{ steps.add-patches.outputs.context || matrix.image }}
        dockerfile: ${{ steps.add-patches.outputs.context || matrix.image }}\Dockerfile.windows

    # refactor (see Git history) if multi-OS images are needed
    - uses: sigstore/cosign-installer@v3.1.1
    - run: cosign sign --yes ${{ steps.build-push.outputs.tags }}

  build:
    needs: get-targets
    permissions:
      packages: write # push images
      id-token: write # OIDC artifact signing
    continue-on-error: true # push tags even if some architectures fail
    strategy:
      fail-fast: false # allows visibility of multiarch support
      matrix:
        image: ${{ fromJson(needs.get-targets.outputs.targets) }}
        os:
        - ubuntu-latest
        - buildjet-2vcpu-ubuntu-2204-arm
        include:
        - os: ubuntu-latest
          arch: linux/amd64
        - os: buildjet-2vcpu-ubuntu-2204-arm
          arch: linux/arm64
    runs-on: ${{ matrix.os }}
    steps:
      # required for builds with custom context
      # https://stackoverflow.com/a/52269934
      # can't use github.repositoryUrl - it uses git://, which seems to be blocked on Windows runners
      - name: Checkout image folder
        run: |
          git clone -n --depth=1 --filter=tree:0 ${{ github.server_url }}/${{ github.repository }} ./
          git sparse-checkout set --no-cone ${{ matrix.image }}
          git checkout ${{ github.sha }}

      - name: Init submodule if present
        id: get-context
        continue-on-error: true
        # user.name and changing GITHUB_TOKEN doesn't work, since it defaults to SSH
        run: |
          git config --global --add url."https://oauth2:${{ secrets.GH_PAT }}@github.com/".insteadOf https://github.com/
          git submodule update --init --recursive ${{ matrix.image }}
          git submodule update --init --recursive ${{ matrix.image }}/${{ matrix.image }}
          echo "context=${{ matrix.image }}/${{ matrix.image }}" >> $GITHUB_OUTPUT

      - name: Copy patches to submodule (Linux)
        if: ${{ steps.get-context.outputs.context && startsWith(matrix.arch, 'linux/') }}
        continue-on-error: true
        working-directory: ${{ matrix.image }}
        run: |
          shopt -s extglob dotglob
          cp !(${{ matrix.image }}) ${{ matrix.image }} -r

      - name: Generate image tags
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ghcr.io/${{ github.repository_owner }}/${{ matrix.image }}
          tags: type=sha

      # format labels for build action
      - uses: frabert/replace-string-action@v2
        id: format-labels
        with:
          pattern: '\n'
          string: ${{ steps.meta.outputs.labels }}
          replace-with: '",'
          flags: 'g'
      - uses: frabert/replace-string-action@v2
        id: format-labels-2
        with:
          pattern: '='
          string: ${{ steps.format-labels.outputs.replaced }}
          replace-with: '="'
          flags: 'g'

      # format arch for image tag
      - uses: frabert/replace-string-action@v2
        id: format-labels-tag
        with:
          pattern: '/'
          string: ${{ matrix.arch }}
          replace-with: '-'
          flags: 'g'

      - name: Check if Dockerfile exists
        id: dockerfileexists
        working-directory: ${{ steps.get-context.outputs.context || matrix.image }}
        run: ls Dockerfile${{ matrix.ext }}
        continue-on-error: true

      # can we use arch in here? suspect windows images could slow linux down otherwise
      # confirmed - particularly bad for off-net ARM64 workers, 3+ minutes
      # https://github.com/satackey/action-docker-layer-caching/issues/169#issuecomment-1217408538
      - uses: jpribyl/action-docker-layer-caching@v0.1.1
        if: ${{ steps.dockerfileexists.outcome == 'success' }}
        continue-on-error: true
        with:
          concurrency: 10
          key: docker-layer-cache-${{ matrix.image }}-${{ steps.format-labels-tag.outputs.replaced }}-{hash}
          restore-keys: |
            docker-layer-cache-${{ matrix.image }}-${{ steps.format-labels-tag.outputs.replaced }}-
            layer-docker-layer-cache-${{ matrix.image }}-${{ steps.format-labels-tag.outputs.replaced }}-

      # docker/build-push-action#18 doesn't support Windows
      # this action doesn't have caching though
      - uses: mr-smithers-excellent/docker-build-push@v6
        if: ${{ steps.dockerfileexists.outcome == 'success' }}
        id: build-push
        with:
          image: ${{ matrix.image }} #
          registry: ghcr.io #
          username: ${{ github.actor }} #
          password: ${{ github.token }} #
          directory: ${{ steps.get-context.outputs.context || matrix.image }}
          dockerfile: ${{ steps.get-context.outputs.context || matrix.image }}/Dockerfile${{ matrix.ext }}
          tags: ${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.version'] }}-${{ steps.format-labels-tag.outputs.replaced }}
          labels: ${{ steps.format-labels-2.outputs.replaced }}"

      - uses: sigstore/cosign-installer@v3.1.1
      - if: ${{ steps.dockerfileexists.outcome == 'success' }}
        run: cosign sign --yes ${{ steps.build-push.outputs.imageFullName }}:${{ steps.build-push.outputs.tags }}
      
      # workaround for lack of matrix support in job.outputs. was almost done, but the team got laid off
      # https://github.com/actions/runner/pull/2477#issuecomment-1501003600
      - if: ${{ steps.dockerfileexists.outcome == 'success' }}
        run: echo '["${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.version'] }}","${{ steps.build-push.outputs.tags }}"]' > tags
      - uses: actions/upload-artifact@v3
        if: ${{ steps.dockerfileexists.outcome == 'success' }}
        with:
          name: ${{ matrix.image }}-${{ hashFiles('tags') || 'none' }}
          path: tags
          if-no-files-found: warn

  manifest:
    needs:
    - get-targets
    - build
    strategy:
      fail-fast: false
      matrix:
        image: ${{ fromJson(needs.get-targets.outputs.images) }}
    runs-on: ubuntu-latest
    permissions:
      packages: write
      id-token: write # OIDC artifact signing
    steps:
    - name: Login to GitHub Container Registry
      uses: docker/login-action@v2
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ github.token }}
  
    - uses: actions/download-artifact@v3
    - id: tags
      run: |
        ls
        shopt -s extglob
        tags="$(cat ${{ matrix.image }}-*/tags | jq --slurp -c 'map(.[] |= "ghcr.io/${{ github.repository_owner }}/${{ matrix.image }}:\(.)") | { tag: .[0][0], images: ([.[][1]] | join(",")) }')"
        echo "tags=$tags" >> $GITHUB_OUTPUT
        echo $tags

    - name: Create and push SHA manifest
      uses: Noelware/docker-manifest-action@0.3.1
      with:
        inputs: ${{ fromJson(steps.tags.outputs.tags)['tag'] }}
        images: ${{ fromJson(steps.tags.outputs.tags)['images'] }}
        push: true
        
    - name: Create and push latest manifest
      uses: Noelware/docker-manifest-action@0.3.1
      with:
        inputs: ghcr.io/${{ github.repository_owner }}/${{ matrix.image }}:latest
        images: ${{ fromJson(steps.tags.outputs.tags)['images'] }}
        push: true

    - uses: sigstore/cosign-installer@v3.1.1
    - run: cosign sign --yes ${{ fromJson(steps.tags.outputs.tags)['tag'] }}
